---
layout: post
title:  Why Java is the wrong language for “enterprise” applications
date:   2005-08-17
tags:   [ technology ]
---

<p>Two and a half years ago, after I was laid off, I had the search engines send me a daily list of every job posting in the Boston area containing the words &#8220;Perl&#8221; or &#8220;Java&#8221;. Virtually nobody wanted to hire a Perl programmer, and virtually every Java position required not only Java, but <a href="http://java.sun.com/j2ee/index.jsp" target="_blank" class="blines3" title="Link outside of this blog"><abbr title="Java 2, Enterprise Edition">J2EE</abbr></a>; not only <abbr>J2EE</abbr>, but experience with a particular brand of <abbr>J2EE</abbr> application server. I had worked with Java in my previous position, but not <abbr>J2EE</abbr>, so I stayed unemployed for ten months.</p> <p>While I was pounding the electronic pavement, I decided to submit to the discipline of the free market, so I signed up for <a href="http://www.javapassion.com/j2ee/index.html" target="_blank" class="blines3" title="Link outside of this blog">a free online course taught by someone at Sun</a> and downloaded the Linux version of Sun&#8217;s <abbr>J2EE</abbr> reference platform. After a few sessions of learning the arcana of the <abbr title="Enterprise Java Beans"><span class="caps">EJB</span></abbr>, I told my wife: &#8220;Now I understand why they have all these positions for <abbr>J2EE</abbr> programmers. Something a Perl hacker can do in an hour, a team of <abbr>J2EE</abbr> programmers have to spend a week on.&#8221;</p> <p>Developers&#8217; backlash against <a href="http://www.vanderburg.org/Blog/2003/11/17" target="_blank" class="blines3" title="Link outside of this blog">the complexity of <abbr>J2EE</abbr></a> is now in full swing, and it seems to be taking two forms. Some people are pushing for expanded use of lighter-weight Java frameworks, such as <a href="http://www.hibernate.org/4.html" target="_blank" class="blines3" title="Link outside of this blog">Hibernate</a>. Others are arguing that the proper solution is to abandon Java altogether, and work with more dynamic languages&#8212;a proposal that has sparked <a href="http://technorati.com/search/%22ruby%20on%20rails%22%20j2ee?language=en" target="_blank" class="blines3" title="Link outside of this blog">much debate</a>, and inspired <a href="http://today.java.net/pub/a/today/2005/06/23/trails.html" target="_blank" class="blines3" title="Link outside of this blog">a Java framework that&#8217;s even simpler than Hibernate</a>. I can&#8217;t boast years of experience implementing the high-traffic database-intensive Web applications, but I have reason to believe that the dynamic-language folks are on the right track.</p> <p>Suppose you&#8217;re writing a Java component to extract information from a relational database and construct objects appropriate for some other application. The classical way to do the job is to write the <em>procedure</em>, in Java code, to extract fields from the result set and construct your objects. <abbr>J2EE</abbr> and its competing frameworks give you an alternative: you can write a <em>description</em> of how database fields map onto your objects, and let the framework generate code that does the translation for you.</p> <p>The authors of your framework have no way of knowing in advance what classes you would be using in your business logic or what schema your database tables would have. The only way they can connect one to the other is by exploiting loopholes in the Java static typing system: for example, <a href="http://www.hibernate.org/16.html#A5" target="_blank" class="blines3" title="Link outside of this blog"><abbr>J2EE</abbr> <span class="caps">CMP</span> systems generate code, while Hibernate uses reflection at run-time</a>. The more your object-relational mapping diverges from &#8220;one database row equals one object&#8221;, the greater the flux through those loopholes.</p> <p>So you need to look at how your architecture is split up between the business logic, the persistence layer, and the mapping, and ask yourself: given that the mapping layer has to work around one of the fundamental traits of Java, its type system, do you really benefit from having a mapping layer that&#8217;s implemented <em>in Java?</em></p> <p>You might answer, &#8220;because <a href="http://www.google.com/search?hs=iG1&amp;hl=en&amp;lr=&amp;client=firefox&amp;rls=org.mozilla%3Aen-US%3Aunofficial&amp;q=%22we%27re+a+java+shop%22&amp;btnG=Search" target="_blank" class="blines3" title="Link outside of this blog">we&#8217;re a Java shop</a>.&#8221; But when you&#8217;re sweating over the proper contents of <span class="caps">XML</span> configuration files, or writing annotations for a tool that <a href="http://xdoclet.sourceforge.net/xdoclet/index.html" target="_blank" class="blines3" title="Link outside of this blog">&#8220;generates 85% of the code for you&#8221;</a>, you&#8217;re not writing Java. So if you expect to be stuck writing a lot of not-Java, you might as well survey all your options, and see which not-Java is best for your needs. Even if your business logic is thousands of lines of Java code, you can still use a more dynamic language for the mapping layer and use <a href="http://java.sun.com/j2se/1.5.0/docs/guide/jni/index.html" target="_blank" class="blines3" title="Link outside of this blog"><span class="caps">JNI</span></a>, wrappers like <a href="http://www.perl.com/pub/a/2003/11/07/java.html" target="_blank" class="blines3" title="Link outside of this blog">Perl&#8217;s Inline::Java module</a>, or <a href="http://www.jcp.org/en/jsr/detail?id=223" target="_blank" class="blines3" title="Link outside of this blog"><span class="caps">JSR</span> 223</a>, when it becomes available, to talk to your business objects&#8217; factories.</p> <p>In the above paragraphs, I keep using the word &#8220;database&#8221;, but the same logic applies to <span class="caps">LDAP</span> directories, <span class="caps">MQS</span>eries messages, <span class="caps">HTTP</span> requests, and <span class="caps">XML</span> documents&#8212;all of which have some kind of structure whose variations (a)&nbsp;depend on the application they are used for and (b)&nbsp;are not constrained by the type system of whatever code ends up processing them. Yet, if you read the <abbr>J2EE</abbr> documentation to glean some non-<a href="http://lists.canonical.org/pipermail/kragen-tol/2005-April/000772.html" target="_blank" class="blines3" title="Link outside of this blog">cynical</a> definition of what the &#8220;Enterprise&#8221; is all about, you would conclude that the stunning complexity of <abbr>J2EE</abbr>, and the five-figure price for its application servers, is what you need to integrate your Java code with <a href="http://java.sun.com/j2ee/1.4/docs/tutorial/doc/IntroXML.html#wp66013" target="_blank" class="blines3" title="Link outside of this blog"><span class="caps">XML</span> files</a>, <a href="http://java.sun.com/j2ee/1.4/docs/tutorial/doc/WebApp.html#wp76431" target="_blank" class="blines3" title="Link outside of this blog">Web servers</a>, <a href="http://java.sun.com/j2ee/1.4/docs/tutorial/doc/EJBConcepts4.html#wp79826" target="_blank" class="blines3" title="Link outside of this blog">databases</a>, and <a href="http://java.sun.com/j2ee/1.4/docs/tutorial/doc/EJBConcepts5.html#wp79967" target="_blank" class="blines3" title="Link outside of this blog">messaging systems</a>. It&#8217;s ironic that Sun devotes so much marketing hype to this use of Java in the &#8220;enterprise&#8221;, and yet this kind of integration goes against <a href="http://c2.com/cgi/wiki?GrainOfTheLanguage" target="_blank" class="blines3" title="Link outside of this blog">the grain of the language</a>.</p>


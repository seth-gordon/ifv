---
layout: post
title:  The impossible parser
date:   2004-08-05T21:27:00Z
tags:   [ technology ]
---

<p>In <a href="http://schemers.org/">Scheme</a>, the Lisp variant that MIT nerds learn in <a href="http://sicp.ai.mit.edu/Spring-2004/">6.001</a>, implementations must be <a href="http://schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-6.html#%_sec_3.5">properly tail-recursive</a>. What does this mean? Suppose you have a the following two Scheme functions (cribbed shamelessly from <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#call_footnote_Temp_46">the 6.001 textbook</a>: <pre class="listing"> (define (factorial n)   (fact-iter 1 1 n))  (define (fact-iter product counter max-count)   (if (> counter max-count)       product       (fact-iter (* counter product)                  (+ counter 1)                  max-count))) </pre> <p>If you ask for <code>(factorial&amp;nbsp;6)</code>, the factorial function will call <code>(fact-iter&amp;nbsp;1&amp;nbsp;1&amp;nbsp;6)</code>, which will call <code>(fact-iter&amp;nbsp;1&amp;nbsp;2&amp;nbsp;6)</code>, and so on up to <code>(fact-iter&amp;nbsp;720&amp;nbsp;7&amp;nbsp;6)</code>. In a <em>non-tail-recursive</em> language, <code>(fact-iter&amp;nbsp;720&amp;nbsp;7&amp;nbsp;6)</code> will return <code>720</code> to its caller, <code>(fact-iter&amp;nbsp;120&amp;nbsp;6&amp;nbsp;6)</code>, which will return the same value to <em>its</em> caller, and all the way back down.</p> <p>A proper Scheme implementation, however, can tell from the structure of the code that all these intermediate function returns are unnecessary, so that <code>(fact-iter&amp;nbsp;720&amp;nbsp;7&amp;nbsp;6)</code> can deliver its return value directly to whatever function called <code>(factorial&amp;nbsp;6)</code> in the first place. No matter how large <code>n</code> is, a Scheme interpreter can evaluate <code>(factorial n)</code> <em>without growing the stack</em>. Where programmers in other languages would use <code>for</code>, <code>while</code>, and other special iterative forms, Scheme programmers just write a recursive procedures like <code>fact-iter</code>.</p> <p>According to Scheme fans, tail recursion is one example of how Scheme doesn&#8217;t force programmers to clutter up their code with useless syntax. According to Scheme foes, tail recursion is one example of how Scheme omits perfectly useful features for the sake of some cult-like ideal of purity. Based on my experiences with a recent Java project, I would like to put in a good word for the fans.</p> <p>I had to write an application that interpreted files in a certain XML format. I chose <a href="http://sax.sourceforge.net">SAX</a> for the job, since it was the fastest free pure-Java XML parser that I knew of. SAX works by setting up a sort of tennis game between two interfaces. The SAX distribution provides an implementation of <a href="http://www.saxproject.org/apidoc/org/xml/sax/XMLReader.html"><code>XMLReader</code></a>, which parses the incoming XML. Every time it sees an &#8220;event&#8221;, such as an opening XML tag, it calls a method on an implementation of <a href="http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html">ContentHandler</a>, which you, the programmer using SAX, have to write.</p> <p>My XML application had two notable features. For my first pass through the document, I wanted to look for some information in <em>the opening tag of the root element</em>, and I didn&#8217;t care about processing the rest of the document. The XML format also had a looping construct, so my content handler had to be able to recognize the beginning and end of the loop, and it had to store up all the events in the middle to be replayed.</p> <p>One catch: The interface for <code>ContentHandler</code> doesn&#8217;t give the content handler any way to communicate with the XML reader that&#8217;s sending the events. The only way to tell the reader &#8220;I know you&#8217;re not done with this document, but stop parsing, I don&#8217;t want to see any more&#8221; is to <a href="http://xml.apache.org/xalan-j/apidocs/org/apache/xml/utils/StopParseException.html">throw an exception</a>. If you want one content handler to hand off its responsibility to another, the rest of the application has to provide the content handler with a reference to the XML reader, so you can call <a href="http://www.saxproject.org/apidoc/org/xml/sax/XMLReader.html#setContentHandler(org.xml.sax.ContentHandler)">the appropriate method</a>. Worst of all, if you&#8217;re trying to collect all of the events within a balanced pair of tags, the content handler has to keep track of how deeply nested the tags are&mdash;even though the XML reader <em>has to</em> keep track of the same information.</p> <p>It would be a nice thing, I thought, if SAX provided another interface, one that let you write a content handler in <a href="http://c2.com/cgi/wiki?ContinuationPassingStyle">continuation passing style</a>. In this XML processor of my imagination, every CPS-content-handler method would take an extra argument, a proxy for the XML reader itself. When the method finished its work and wanted the parse to continue, it could just call <code>reader.continueParsing(this)</code>. If it wanted to hand off work to another CPS-content-handler, it would call <code>reader.continueParsing(otherHandler)</code>. If it needed information about how deeply nested the current element was, it could call <code>reader.getDepth()</code>; other methods could provide other useful information about the context of the event being processed, such as the names of enclosing tags. And if a CPS-content-handler method wanted to stop parsing, it would simply exit without calling <code>reader.continueParsing()</code>.</p> <p>(The Java servlet filter API uses this strategy. If a <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/Filter.html#doFilter(javax.servlet.ServletRequest,%20javax.servlet.ServletResponse,%20javax.servlet.FilterChain)">filter</a> wants to pass control to the next filter in the filter chain, it calls <code>chain.doFilter()</code>; if it wants to block further request processing, it doesn&#8217;t call that method.)</p> <p>But alas! Even though <a href="http://java.sun.com/features/2003/05/steele_qa.html">one of the architects of Scheme</a> has spent the last ten years working for Sun, Java is not guaranteed to be properly tail-recursive. Therefore, all these calls from the XML reader to the CPS-content-handler and back would add two stack frames for every parsing event, until the whole parse was completed&mdash;or, more likely, until the stack overflowed and a fatal exception stopped the whole application.</p> <p>Perhaps I can convince the Powers that Be at <a href="http://jenzabar.net/">my employer</a> to write their next multi-million-dollar <abbr title="Enterprise Resource Planning">ERP</abbr> application in Scheme, instead of Java. I&#8217;m not exactly holding my breath.</p></p>

